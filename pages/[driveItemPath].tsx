import type { NextPage, InferGetStaticPropsType } from 'next';
import Head from 'next/head';
import axios from 'axios';
import styled from 'styled-components';
import { getDriveIdByPath } from 'utility/getDriveIdByPath';
import { getDriveItem } from 'blog-app-shared';
import { loadDrivePathes, getDrivePathes } from 'fetch-cache';
import { SWRConfig } from 'swr';
import { Mdx } from 'components/Mdx';
import { serializeMdx } from 'components/Mdx';

const DriveItemPath: NextPage<InferGetStaticPropsType<typeof getStaticProps>> = ({
  fallback,
  error,
}) => {
  return (
    <>
      <Head>
        <title>Blog it</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>
      <SWRConfig
        value={{
          fallback,
          refreshInterval: 5000,
          fetcher: (url: string) => axios.get(url).then((response) => response.data),
        }}
      >
        <Wrapper>{!!error ? error : <Mdx getUrl={Object.keys(fallback)[0]} />}</Wrapper>
      </SWRConfig>
    </>
  );
};

export default DriveItemPath;

const Wrapper = styled.section`
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 100%;
`;

export async function getStaticProps(context: any) {
  // console.log('context', context);
  console.log('getStaticProps run');
  try {
    // console.log('getStaticProps before getNavItems');
    // res.props.navItems = await getNavItems();
    // console.log('getStaticProps after getNavItems');
    const driveItemId = await getDriveIdByPath(context.params.driveItemPath);
    if (driveItemId) {
      const postResponse = await getDriveItem(driveItemId);
      const sourceRaw = postResponse.data.content;
      const mdxSource = await serializeMdx(sourceRaw);
      return {
        props: {
          fallback: {
            [`/api/getDriveItem?id=${driveItemId}`]: mdxSource,
            // '/api/getDriveItem?id=${driveItemId}': '',
          },
          error: postResponse.error,
        },
        revalidate: 3600,
      };
    }
  } catch (e: any) {
    console.log('error', e);
    return {
      props: {
        error: e + '',
      },
    };
  }
}

export async function getStaticPaths() {
  await loadDrivePathes();
  // await loadNavItems();
  const cachedDrivePathes = await getDrivePathes();
  return {
    paths: cachedDrivePathes
      .filter((cur) => cur.path !== '--nav--')
      .map((cur) => {
        return {
          params: {
            driveItemPath: cur.path,
          },
        };
      }),
    fallback: 'blocking',
  };
}
